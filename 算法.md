# **蓝桥杯入门算法**

## 一 .原码 反码 补码

### 1.正数和负数的原码

> 这里我们以4为例子 ，由于大家电脑普遍为64位 而int 类型的大小为32 位，所以这里以4位 为例子
>
> 正数和负数的二进制原码**第一位表示符号位**，其余位 一样 ，***0**代表**正数** **1**代表**负数***。
>
> 4和-4的原码如下：

|  0   |  1   |  0   |  0   |
| :--: | :--: | :--: | :--: |

|  1   |  1   |  0   |  0   |
| :--: | :--: | :--: | :--: |

> 可以看到4 和 -4 的原码除了最高位也就是第一位不同 ，其余则相同。

------

### 2.正数和负数的反码

>在计算机中，原码，反码，补码的产生 其实是为了计算机能够处理正数和负数的操作，
>
>比如, 计算机如何处理 4 + (-4) 下面让我们站在上帝视角，自己操作一遍
>
>这里我们以八位进行表示，4 原码为（0000 0100） -4原码为（1000 0100） 

| 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 0    | 0    | 0    | 1    | 0    | 0    |
| 0    | 0    | 0    | 0    | 1    | 0    | 0    | 0    |

> 我们会发现 结果为 0000 1000 也就是8 没错，
>
> 如果按4 和-4 的原码来计算 那么4+(-4)=（0000 0100）+（1000 0100）=0000 1000=8

> 因此计算机提出了反码 ，正数的反码和原码相同，负数的反码则是负数的原码除了最高位也就是符号位不变，其他都取反
>
> 因此下面给出 4 和 -4 的 的反码，然后对反码进行相加。

| 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 1    | 1    | 1    | 1    | 0    | 1    | 1    |
| 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |

> 我们发现，结果为 8个1（1111 1111）反码   ，由于这里是反码，我们取反 为 1000 0000 ，会发现答案为**-0**不是我们想要的**0**

------

### 3.正数和负数的补码

> 由于原码，反码，补码的出现是为了服务于负数，所以我们都知道 正数的原码 反码 补码 都相同
>
> 而负数的补码则是在负数的原码的基础上取反码在加1即可 。 **也就是反码+1**
>
> 那下面我们来用补码进行 4和 -4的相加

| 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 1    | 1    | 1    | 1    | 1    | 1    | 0    | 0    |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |

>由于这里8位表示不够，答案应该为 0000 0000 这里是补码 ，多余的我们舍弃 我们转成反码为  11111 1111   
>
> 然后在加1 就为   0000 0000  这里左侧多出来俩0是舍弃 **答案为0**



>### 总结，正数的原，反，补码都相同，
>
>### 负数的原码:等于正数的原码改变最高位为1 ，就是4（0000 0100）-4（1000 0100）
>
>### 负数的反码：负数的原码除了最高位也就是符号位不变，其余取反
>
>### 负数的补码：负数的反码+1

------

## 二.一个数在二进制下有多少个1

### 1.&与运算

>与运算口诀 ，都为1则为1，其余则为0

>| 二进制数 1 | 运算符 | 二进制数 2 | 结果    |
>| ---------- | ------ | ---------- | ------- |
>| 0 1 0 0    | &      | 0 0 0 1    | 0 0 0 0 |

> 可以看到 4 &1 结果为 0，但是我们可以通过用右移运算符>> 来进行移位 把0100 右移一次为0010 再一次为0001 那么现在的0001&0001 结果就是1了，但是什么时候不移了呢，也就是当0100 右移了3次，变成 0000了也就是0 不移了。
>
> 所以我们可以写一个死循环，在这个数为0 的时候退出，如果这个数&1（0001）为1 那么就说明它有一个1。

> 下面附上java代码：

> ```Java
>     static int way(int n) {
>         int count = 0;
>         while (n != 0) {
>             if ((n & 1) == 1) {
>                 count++;
>             }
>             n = n >> 1;
>         }
>         return count;
>     }
> 
> ```

### 2.lowbit运算

> 什么是lowbit运算呢，从英文可以看出，low为低，bit为位的意思，
>
> 因此lowbit就是可以计算出一个数的最低位1往后的数
>
> 写为：5&（-5） 这也就是lowbit（5）求出5的最低位往后的数，我们来用补码进行&运算验证一下

| 0    | 1    | 0    | 1    |
| ---- | ---- | ---- | ---- |
| 1    | 0    | 1    | 1    |
| 0    | 0    | 0    | 1    |

>我们发现 结果为 补码  0001 为正数 所以原码为1 ，然后拿5来 剪0001 等于 4 ，在用4进行lowbit运算 为4    4-4=0 停止，一共运算了两次，也就是每次都减去最低位的1往后的数字。从而求出有几个 1.

> ```JAVA
>     static int lowbit(int n){
>             int count=0;
>         while (n!=0){
>             n-=n & (-n);
>             count++;
>         }
>         return count;
>     }
> }
> 
> ```

### 3.一个二进制下第n位的数是几

> ```java
>    static int way(int n,int index){
> 
>         return n >> (index - 1) & 1;
>     }
> ```

><img src="D:\代码文件\蓝桥杯入门算法Code\lanqiaoAlgorithm\pictures\二进制第n位为几.png" alt="代码截图"  />

>![](D:\代码文件\蓝桥杯入门算法Code\lanqiaoAlgorithm\pictures\二进制第n位为几.png)
>
>

## 三. 二分查找

##### 1.二分查找标准模板

> ```
> //最基本模板：左闭右闭查找一个数并返回索引，不存在返回-1
> 	public static int t1(int nums[],int target) {
> 		//左闭右闭的意思就是索引能取到数组的第一个索引和最后一个索引，索引[0,nums.length-1]
> 		//左闭右开的意思是左边能取到第一个索引，右边取不到，索引[0,nums.length)
> 		//左开右闭，左开右开等同理，其实这些的思路都差不多，就是判断条件有差别
> 		//怕记太多会乱掉，下面都使用左闭右闭来编写
> 		int left = 0;
> 		int right = nums.length-1;
> 		//左闭右闭的终止条件是left<=right，即left+1=right时结束遍历
> 		while(left<=right) {
> 			//取到中间数的时候最好像我这样写，能防止数据溢出同时使用位运算代替除法提高性能
> 			//相当于是int mid = (left+right)/2;
> 			//注意这里位运算外面一定一定一定要加个括号保证先算，不然后面会陷入死循环
> 			int mid = left+((right-left)>>1);
> 		    if(nums[mid]==target) {//当中间数等于目标值时，直接返回其索引
> 		    	return mid;
> 		    }else if(nums[mid]<target){//当中间值小于目标值，说明目标值在右侧，左索引向右移
> 		    	left = mid+1;
> 		    }else {//当中间值大于目标值，说明目标值在左侧，右索引向左移
> 		    	right = mid-1;
> 		    }
> 		}
> 		return -1;
> 	}
> ```
>
> 

> 1.左边界  最大值最小满足题目

> ```
> int left = lower_bound, right = upper_bound;
> while (left <= right) {
>     int mid = left + (right - left) / 2;
>     if (满足条件(mid)) {
>         // 可能还有更小的满足条件的解
>         right = mid - 1;
>     } else {
>         left = mid + 1;
>     }
> }
> // left 指向第一个满足条件的解（或没有满足条件的情况）
> 
> ```

> 2.右边界   最小值最大满足题目

> ```
> int left = lower_bound, right = upper_bound;
> while (left <= right) {
>     int mid = left + (right - left) / 2;
>     if (满足条件(mid)) {
>         // 可能还有更大的满足条件的解
>         left = mid + 1;
>     } else {
>         right = mid - 1;
>     }
> }
> // right 指向最后一个满足条件的解
> 
> ```

##### 2. 二分查找区分

![](D:\代码文件\蓝桥杯入门算法Code\lanqiaoAlgorithm\pictures\二分区别.png)

> 
>
> 滑动窗口模板代码

> ```
> public class SlidingWindowDemo {
>     public static void main(String[] args) {
>         // 示例数组
>         int[] arr = {1, 3, -1, -3, 5, 3, 6, 7};
>         int k = 3;  // 窗口大小
> 
>         // 计算初始窗口的和
>         int currentSum = 0;
>         for (int i = 0; i < k; i++) {
>             currentSum += arr[i];
>         }
>         int maxSum = currentSum;
> 
>         // 滑动窗口，从第 k 个元素开始，每次加入一个新元素、减去最左边的旧元素
>         for (int i = k; i < arr.length; i++) {
>             currentSum = currentSum + arr[i] - arr[i - k];
>             maxSum = Math.max(maxSum, currentSum);
>         }
>         
>         System.out.println("窗口大小为 " + k + " 的最大和为: " + maxSum);
>     }
> }
> ```

>2. 前缀和算法示例

前缀和算法通常用于快速求区间和。下面的示例中，先计算数组的前缀和数组，然后利用前缀和数组在 O(1) 时间内求任意区间和。

> ```
> public class PrefixSumDemo {
>     public static void main(String[] args) {
>         // 示例数组
>         int[] arr = {2, 4, 5, 7, 9, 3, 8};
>         int n = arr.length;
>         
>         // 构造前缀和数组，prefixSum[0] = 0
>         int[] prefixSum = new int[n + 1];
>         prefixSum[0] = 0;
>         for (int i = 1; i <= n; i++) {
>             prefixSum[i] = prefixSum[i - 1] + arr[i - 1];
>         }
>         
>         // 举例求解区间 [l, r] 的和，假设数组下标从 0 开始
>         int l = 2, r = 5; // 计算 arr[2] 到 arr[5] 的和
>         int sum = prefixSum[r + 1] - prefixSum[l];
>         
>         System.out.println("区间 [" + l + ", " + r + "] 的和为: " + sum);
>     }
> }
> 
> ```

3.快速幂运算

> ```
> // 快速幂（快速计算 a^b % mod）
>     static long modPow(long a, long b, int mod) {
>         long result = 1;
>         a %= mod;
>         while (b > 0) {
>             if ((b & 1) == 1) {
>                 result = result * a % mod;
>             }
>             a = a * a % mod;
>             b >>= 1;
>         }
>         return result;
>     }
> ```
>
> 
